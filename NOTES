-- https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/guide-to-ghc-extensions/pattern-and-guard-extensions#viewpatterns
-- {-# LANGUAGE ViewPatterns #-}
-- {-# LANGUAGE PatternGuards #-}

-- | Result
-- http://hackage.haskell.org/package/HTTP-4000.3.7/docs/Network-Stream.html#t:Result
-- type Result a = Either ConnError a
-- This is the type returned by many exported network functions.
-- -- | This is the type returned by many exported network functions.
-- type Result a = Either ConnError   {- error  -}
--                        a           {- result -}
-- lift always lifts from the "previous" layer.
-- liftIO always lifts from the IO layer

-- | ParseRequest
-- Convert a URL into a Request.
-- parseRequest :: MonadThrow m => String -> m Request
-- http://hackage.haskell.org/package/http-client-0.5.7.0/docs/Network-HTTP-Client.html#v:parseRequest
--
-- > request' <- parseRequest "POST http://httpbin.org/post"
-- >     let request
-- >             = setRequestMethod "PUT"
-- >             $ setRequestPath "/put"
-- >             $ setRequestQueryString [("hello", Just "world")]
-- >             $ setRequestBodyLBS "This is my request body"
-- >             $ setRequestSecure True
-- >             $ setRequestPort 443
-- >             $ request'
-- >     response <- httpJSON request
-- | FindHeader
-- https://hackage.haskell.org/package/HTTP-4000.3.7/docs/Network-HTTP-Headers.html
-- findHeader :: HasHeaders a => HeaderName -> a -> Maybe String
-- findHeader hdrNm x looks up hdrNm in x, returning the first
-- header that matches, if any

-- | Left
-- This function is defined in Control.Arrow.
-- https://hackage.haskell.org/package/base-4.10.0.0/docs/Control-Arrow.html
-- https://www.haskell.org/arrows/
-- Feed marked inputs through the argument arrow, passing the rest through
-- unchanged to the output.
-- left :: (a -> c) -> Either a b -> Either c b
-- left f (Left x)  = Left (f x)
-- left _ (Right x) = Right x

-- | Either
-- https://hackage.haskell.org/package/base-4.10.0.0/docs/Data-Either.html
-- either :: (a -> c) -> (b -> c) -> Either a b -> c
-- either f _ (Left x)     =  f x
-- either _ g (Right y)    =  g y
--
-- Case analysis for the Either type. If the value is Left a, apply the first
-- function to a; if it is Right b, apply the second function to b.
--
-- We create two values of type Either String Int, one using the Left
-- constructor and another using the Right constructor. Then we apply "either"
-- the length function (if we have a String) or the "times-two" function (if
-- we have an Int):
--
-- let s = Left "foo" :: Either String Int
-- let n = Right 3 :: Either String Int
-- either length (*2) s
-- >> 3
-- either length (*2) n
-- >> 6

-- | Maybe
-- https://hackage.haskell.org/package/base-4.10.0.0/docs/Data-Maybe.html
--   maybe :: b -> (a -> b) -> Maybe a -> b
--   maybe n _ Nothing  = n
--   maybe _ f (Just x) = f x
--
-- The maybe function takes a default value, a function, and a Maybe value. If
-- the Maybe value is Nothing, the function returns the default value.
-- Otherwise, it applies the function to the value inside the Just and returns
-- the result.
--
-- >> maybe False odd (Just 3)
-- True
-- >> maybe False odd Nothing
-- False
--
-- Read an integer from a string using readMaybe. If we succeed, return twice
-- the integer; that is, apply (*2) to it. If instead we fail to parse an
-- integer, return 0 by default:
--
-- >> import Text.Read ( readMaybe )
-- >> maybe 0 (*2) (readMaybe "5")
-- 10
-- >>> maybe 0 (*2) (readMaybe "")
-- 0
--
-- Apply show to a Maybe Int. If we have Just n, we want to show the
-- underlying Int n. But if we have Nothing, we return the empty string
-- instead of (for example) "Nothing":
--
-- >> maybe "" show (Just 5)
-- "5"
-- >> maybe "" show Nothing
-- ""

-- | TChan
--- TChan is an abstract type representing an unbounded FIFO channel:
--  https://hackage.haskell.org/package/stm-2.4.4.1/docs/Control-Concurrent-STM-TChan.html
--- A TQueue is like a TChan, with two important differences:
--  - it has faster throughput than both TChan and Chan (although the costs are
--    amortised, so the cost of individual operations can vary a lot).
--  - it does not provide equivalents of the dupTChan and cloneTChan
--    operations.
--  The implementation is based on the traditional purely-functional queue
--  representation that uses two lists to obtain amortised O(1) enqueue and
--  dequeue operations.
--  https://hackage.haskell.org/package/stm-2.4.4.1/docs/Control-Concurrent-STM-TQueue.html

-- | ($)
-- ($) has loosest fixity, infixr 0

-- | Left
-- left is in Control.Arrow
-- left f (Left x) = Left $ f x
-- left   (Right x) = Right x

-- | Finally
-- finally has default tight fixity, infixl 9
-- forkTimes k alive act =
--   (replicateM_ k . forkIO) $ (act `finally` (atomically $ (modifyTVar_ alive (subtract 1))))

-- | Forever
-- ghci> :m +Control.Monad
-- ghci> :type forever
-- forever :: (Monad m) => m a -> m ()

-- | SimpleHTTP
-- http://hackage.haskell.org/package/HTTP-4000.3.7/docs/Network-HTTP.html
-- simpleHTTP :: HStream ty => Request ty -> IO (Result (Response ty))
-- simpleHTTP req transmits the Request req by opening a direct, non-persistent
-- connection to the HTTP server that req is destined for, followed by
-- transmitting it and gathering up the response as a Result. Prior to sending
-- the request, it is normalized (via normalizeRequest). If you have to mediate
-- the request via an HTTP proxy, you will have to normalize the request
-- yourself. Or switch to using Browser instead.
-- Examples:
-- simpleHTTP (getRequest "http://hackage.haskell.org/")
-- simpleHTTP (getRequest "http://hackage.haskell.org:8012/")

-- | ErrorT monad transformer
-- ExceptT monad transformer can be used to add error handling to another monad.
-- newtype ExceptT e m a :: * -> (* -> *) -> * -> * #
--
-- A monad transformer that adds exceptions to other monads.
-- ExceptT constructs a monad parameterized over two things:
-- e - The exception type.
-- m - The inner monad.
-- The return function yields a computation that produces the given value,
-- while >>= sequences two subcomputations, exiting on the first exception.
-- Constructors
-- ExceptT (m (Either e a))

-- | Control Monad Except
-- import Control.Monad.Except
--
-- -- An IO monad which can return String failure.
-- -- It is convenient to define the monad type of the combined monad,
-- -- especially if we combine more monad transformers.
-- type LengthMonad = ExceptT String IO
--
-- main = do
--   -- runExceptT removes the ExceptT wrapper
--   r <- runExceptT calculateLength
--   reportResult r
--
-- -- Asks user for a non-empty string and returns its length.
-- -- Throws an error if user enters an empty string.
-- calculateLength :: LengthMonad Int
-- calculateLength = do
--   -- all the IO operations have to be lifted to the IO monad in the monad stack
--   liftIO $ putStrLn "Please enter a non-empty string: "
--   s <- liftIO getLine
--   if null s
--     then throwError "The string was empty!"
--     else return $ length s
--
-- -- Prints result of the string length calculation.
-- reportResult :: Either String Int -> IO ()
-- reportResult (Right len) = putStrLn ("The length of the string is " ++ (show len))
-- reportResult (Left e) = putStrLn ("Length calculation failed with error: " ++ (show e))

-- | Nub
-- http://hackage.haskell.org/package/base-4.10.0.0/docs/Data-List.html#v:nub
--   /O(n^2)/. The 'nub' function removes duplicate elements from a list.
-- In particular, it keeps only the first occurrence of each element.
-- (The name 'nub' means \`essence\'.)
-- It is a special case of 'nubBy', which allows the programmer to supply
-- their own equality test.
-- nub :: (Eq a) => [a] -> [a]
-- nub =  nubBy (==)
--
-- | The 'nubBy' function behaves just like 'nub', except it uses a
-- user-supplied equality predicate instead of the overloaded '=='
-- function.
-- nubBy                   :: (a -> a -> Bool) -> [a] -> [a]
-- -- #ifdef USE_REPORT_PRELUDE
-- nubBy eq []             =  []
-- nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
-- -- #else
-- -- stolen from HBC
-- nubBy eq l              = nubBy' l []
--   where
--     nubBy' [] _         = []
--     nubBy' (y:ys) xs
--        | elem_by eq y xs = nubBy' ys xs
--        | otherwise       = y : nubBy' ys (y:xs)

-- | ThreadScope
-- https://wiki.haskell.org/ThreadScope
-- stack ghc -- -O2 -threaded --make src/UrlChecker.hs

-- | GetOpt
-- http://hackage.haskell.org/package/base-4.10.0.0/docs/System-Console-GetOpt.html
-- data ArgOrder a
-- What to do with options following non-options
-- Constructors
-- RequireOrder	               no option processing after first non-option
-- Permute                     freely intersperse options and non-options
-- ReturnInOrder (String -> a) wrap non-options into options
--
-- | The HTTP package
-- http://hackage.haskell.org/package/HTTP
-- https://github.com/haskell/HTTP
-- http://hackage.haskell.org/package/HTTP-4000.3.7/docs/Network-HTTP.html
-- http://hackage.haskell.org/package/HTTP-4000.3.7/docs/Network-Stream.html#t:Result
-- import Network.HTTP hiding (Done)
-- import Network.Stream ( Result )
--
-- | The http-streams package
-- http://hackage.haskell.org/package/http-streams
-- https://github.com/afcowie/http-streams/
-- http://hackage.haskell.org/package/http-streams-0.8.5.3/docs/Network-Http-Client.html
--
-- | The http-client package
-- http://hackage.haskell.org/package/http-client
-- http://hackage.haskell.org/package/http-client-tls
-- https://github.com/snoyberg/http-client
-- Tutorial:
-- https://haskell-lang.org/library/http-client

-- https://hackage.haskell.org/package/http-client-0.5.7.0/docs/Network-HTTP-Client.html#v:responseStatus
--
-- httpLbs :: Request -> Manager -> IO (Response ByteString)
-- A convenience wrapper around withResponse which reads in the entire response
-- body and immediately closes the connection. Note that this function performs
-- fully strict I/O, and only uses a lazy ByteString in its response for memory
-- efficiency. If you are anticipating a large response body, you are encouraged
-- to use withResponse and brRead instead.